function neonetwork_import_filter_v4() {
  if (roa_check(roa_v4, net, bgp_path.last) = ROA_INVALID) then {
    print "[neonetwork] roa fail for ", net, " as ", bgp_path.last, " neighbor ", bgp_path.first;
    bgp_large_community.add((DN42_AS, LT_ROA_ERROR, LT_ROA_FAIL));
    bgp_large_community.add((DN42_AS, LT_POLICY, LT_POLICY_NOEXPORT));
    bgp_local_pref = 0;
  } else if (roa_check(roa_v4, net, bgp_path.last) = ROA_UNKNOWN) then {
    print "[neonetwork] roa unknown for ", net, " as ", bgp_path.last, " neighbor ", bgp_path.first;
    bgp_large_community.add((DN42_AS, LT_ROA_ERROR, LT_ROA_UNKNOWN));
    bgp_large_community.add((DN42_AS, LT_POLICY, LT_POLICY_NOEXPORT));
    bgp_local_pref = 0;
  }
  if net ~ RESERVED_IPv4 && net !~ LTNET_IPv4_NET then accept;
  reject;
}

function neonetwork_export_filter_v4() {
  bgp_path.delete(NEONETWORK_AS);
  bgp_path.delete([4225470000..4225479999]);
  if net !~ RESERVED_IPv4 then reject;
  if (DN42_AS, LT_POLICY, LT_POLICY_NOEXPORT) ~ bgp_large_community then reject;

  if net ~ [ 172.22.76.184/29+ ] then bgp_path.prepend(DN42_AS);
  if net ~ [ 172.22.76.96/27+ ] then bgp_path.prepend(DN42_AS);
  if net ~ [ 10.127.10.0/24+ ] then bgp_path.prepend(NEONETWORK_AS);

  if (
    (bgp_path.last != 0 && roa_check(roa_v4, net, bgp_path.last) != ROA_VALID)
    || (bgp_path.last = 0 && roa_check(roa_v4, net, NEONETWORK_AS) != ROA_VALID) 
  ) then {
    #print "[neonetwork export] roa fail for ", net, " as ", bgp_path.last, " neighbor ", bgp_path.first;
    reject;
  }
  accept;
}

function neonetwork_import_filter_v6() {
  if (roa_check(roa_v6, net, bgp_path.last) = ROA_INVALID) then {
    print "[neonetwork] roa fail for ", net, " as ", bgp_path.last, " neighbor ", bgp_path.first;
    bgp_large_community.add((DN42_AS, LT_ROA_ERROR, LT_ROA_FAIL));
    bgp_large_community.add((DN42_AS, LT_POLICY, LT_POLICY_NOEXPORT));
    bgp_local_pref = 0;
  } else if (roa_check(roa_v6, net, bgp_path.last) = ROA_UNKNOWN) then {
    print "[neonetwork] roa unknown for ", net, " as ", bgp_path.last, " neighbor ", bgp_path.first;
    bgp_large_community.add((DN42_AS, LT_ROA_ERROR, LT_ROA_UNKNOWN));
    bgp_large_community.add((DN42_AS, LT_POLICY, LT_POLICY_NOEXPORT));
    bgp_local_pref = 0;
  }
  if net ~ RESERVED_IPv6 && net !~ LTNET_IPv6_NET then accept;
  reject;
}

function neonetwork_export_filter_v6() {
  bgp_path.delete(NEONETWORK_AS);
  bgp_path.delete([4225470000..4225479999]);
  if net !~ RESERVED_IPv6 then reject;
  if (DN42_AS, LT_POLICY, LT_POLICY_NOEXPORT) ~ bgp_large_community then reject;

  if net ~ [ fdbc:f9dc:67ad::/48+ ] then bgp_path.prepend(DN42_AS);
  if net ~ [ fd10:127:10::/48+ ] then bgp_path.prepend(NEONETWORK_AS);

  if (
    (bgp_path.last != 0 && roa_check(roa_v6, net, bgp_path.last) != ROA_VALID)
    || (bgp_path.last = 0 && roa_check(roa_v6, net, NEONETWORK_AS) != ROA_VALID) 
  ) then {
    #print "[neonetwork export] roa fail for ", net, " as ", bgp_path.last, " neighbor ", bgp_path.first;
    reject;
  }
  accept;
}

template bgp neonetwork_peers {
  local as NEONETWORK_AS;
  direct;
  path metric 1;
  enable extended messages on;
  enforce first as on;
  ipv4 {
    next hop self yes;
    import keep filtered;
    extended next hop yes;
    import filter { neonetwork_import_filter_v4(); };
    export filter { neonetwork_export_filter_v4(); };
  };
  ipv6 {
    next hop self yes;
    import keep filtered;
    extended next hop yes;
    import filter { neonetwork_import_filter_v6(); };
    export filter { neonetwork_export_filter_v6(); };
  };
};

include "/etc/bird/neonetwork/peers.conf";
